require 'spec_helper'

describe Magick::TTIConverter do
  let (:text_wrapper) { Magick::TTIConverter.new("./tmp/images/") }
  
  it 'has a version number' do
    expect(Magick::TTIConverter::VERSION).not_to be nil
  end

  describe '#initialize' do
    subject { text_wrapper }
      
    it "should be an instance of TTIConverter" do
      expect(subject).to be_a Magick::TTIConverter
    end
  end
  t2=Magick::TTIConverter.new("./tmp/images/")
  tex1 = <<-TEXTHE
  Well, the obvious advantage of VARCHAR is that you can impose a DBMS-level length constraint on the data coming in â€” which, while very useful, also comes with signficant drawbacks. If you want to change the max length to be larger, postgres will have to rewrite the table, which can take a long time and requires an exclusive table lock for the entirety of the operation. Clearly not ideal in a live environment, especially for larger tables

EDIT: The above crossed out claims are not true since PG 9.2 if you are making the max larger, according to this HN comment. It's still true (without hacks) for making the constraint smaller, though.

If you were to impose these constraints in your application code instead, changing the max length would be a trivial commit.

However, it can still be useful to have lengths checked in postgres. Luckily there are plenty of other options that can be used with TEXT fields to acheive the same effect with similar performance: domains, constraints, and triggers come to mind.

EDIT: I suppose it'd probably be useful to provide an example of using TEXT and constraints to create fields with more flexibility than VARCHAR. Here's a code sample that creates a domain for storing usernames:

CREATE DOMAIN dom_username TEXT CHECK (
    LENGTH(VALUE) > 3 AND
    LENGTH(VALUE) < 200 AND
    VALUE ~ '^[A-Za-z][A-Za-z0-9]+$'
);

CREATE TABLE user (
  name dom_username,
  email TEXT
);

It should be obvious why this is leaps and bounds better than varchar: we get checks for min and max length, and we validate that the username is only alphanumeric starting with a letter. Also, it's super easy to change these constraints later.
TEXTHE
t2.make_image(tex1, file_name: 'lart.png')
  describe '#make_image' do
    src_text =<<-TEXTDESC
    Two-factor authentication, or 2FA, is a way of logging into websites that requires more than just a password. Using a password to log into a website is susceptible to security threats, because it represents a single piece of information a malicious person needs to acquire. The added securitythat 2FA provides is requiring additional information to sign in. In GitHub's case, this additional information is an authentication code delivered to your cell phone that's generated by an application on your smartphone or sent as a text message (SMS). After 2FA is enabled, GitHub generates an authentication code that is sent to your phone any time someone attempts to sign into your GitHub account. The only way someone can sign into your account is if they know both your password and have access to the authentication code on your phone.
    TEXTDESC

    it "should create a new image file with specified name" do
      file_name = "auth_info.jpg"
      text_wrapper.send(:make_image, src_text, file_name: file_name)
      expect(File).to exist(text_wrapper.instance_variable_get(:@path) + file_name)
    end

    it "should create a new image file with default name" do
      text_wrapper.send(:make_image, src_text)
      expect(File).to exist(text_wrapper.instance_variable_get(:@path) + "image.jpg")
    end
  end

  context "private methods" do
    describe '#get_index_and_new_line_option_for_nearest_space' do
      describe 'return -1 when doesnt exist spaces'  do
        without_spaces = "thisistestmsg"
        subject { text_wrapper.send(:get_index_and_new_line_option_for_nearest_space, without_spaces, { 
                                      finish: without_spaces.length })}
        it { expect(subject).to eq [-1, true] }
      end

      describe 'return index when finding a space' do
        let(:with_one_space) { "this istestmsg" }
        subject { text_wrapper.send(:get_index_and_new_line_option_for_nearest_space, 
                                      with_one_space,
                                      { 
                                        start: 0,
                                        finish: with_one_space.length
                                      })
                }
        it { expect(subject).to eq [4, true] }
      end

      describe 'return index right nearest space when some presence spaces' do
        some_spaces = " this is test msg"
        subject { text_wrapper.send(:get_index_and_new_line_option_for_nearest_space,
                                     some_spaces, 
                                     {
                                        start: 1,
                                        finish: some_spaces.length
                                      }
                                    )
                }

        it {expect(subject).to eq [13, true] }
      end

      describe 'returns first new line' do
        text = "Whether you believe wearables are a dynamic and\ngrowing"
        subject { text_wrapper.send(:get_index_and_new_line_option_for_nearest_space,
                                      text, {
                                          start: 0,
                                          finish: text.length
                                        })
        }
        it { expect(subject).to eq [47, false] }
      end
    end
  end
end